<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="author" content="Adrien Cheype">
    <title>Systèmes d'exploitation</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/synthese_cours_SE.css"/>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
<div class="reveal">
<div class="slides">

<section>
    <h1>Systèmes d'exploitation</h1>
    <h2>Adrien Cheype</h2>
    <h4>Institut de Recherche pour le Développement - Nouméa</h4>
</section>

<section>
    <section data-markdown>
        <script type="text/template">
            # Organisation du cours
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Déroulement
            - basé sur le support de cours de Teodor Knapik <br><br>

            ### Heures
            - 5 séances de cours (10H)
            - 3 séances de TD (6H)
            - 7 séances de TP (14H)
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ### Devoirs
            - TP avec Linux : compte-rendu à rendre pour chaque TP
            - des devoirs  « maison » facultatif (TD)
            - une épreuve de contrôle continu (courant septembre)
            - un examen final (semaine du 10 octobre)
            - un examen de rattrapage (semaine du 21 novembre)<br><br>

            ### Notes
            - note finale = 2/3 * note de l'examen + 1/3 * note du CC
                - pour le rattrapage, le CC compte uniquement si meilleur note
            - note du CC = 1/2 * (épreuve de contrôle continu + moyenne des TP) + bonus
            - bonus = devoirs maison + QCM en début de cours
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Objectifs
            - comprendre l'organisation d'un système d'exploitation, ses structures de données et les principaux algorithmes
            - connaître la mise en oeuvre dans le cas de Linux
            - maitriser les commandes de base et les scripts sous Linux
        </script>
    </section>
</section>

<section>
    <section data-markdown>
        <script type="text/template">
            # Introduction aux systèmes d'exploitation
        </script>
    </section>

    <section data-background-color="#2eada6">
        <h2 style="font-size:5.6em;">Brainstorming</h2>
        <p style="color: white;">« remue-ménage » ➪ récolte d'idées nombreuses et originales<br>(ne pas juger, se laisser aller)</p>
        <img alt="brainstorming.jpg" src="images/brainstorming.jpg"/>
    </section>

    <section data-background-color="#2eada6">
        <h3>Idées principales</h3>
        <img alt="mapmind_simple_SE.png" src="images/mapmind_simple_SE.png"/>
    </section>

    <section>
        <h2>Logiciels</h2>
        <div class="flex-pad">
            <div style="width: 65%;" data-markdown>
                <script type="text/template">
                    - Qu'est-ce qu'un ordinateur ?
                        - sans *logiciel*, inutilisable

                    - *logiciel* : ensemble d'instructions exécutables par une machine et permettant de traiter des données
                </script>
            </div>
            <div style="width: 20%;" data-markdown>
                <script type="text/template">
                    ![ordinateur.png](images/ordinateur.png)
                </script>
            </div>
        </div>
        <div data-markdown>
            <script type="text/template">
                - Deux types de logiciels
                    - *Programmes systèmes* qui permettent le fonctionnement de l'ordinateur
                    - *Programmes d'application* qui résolvent les problèmes des utilisateurs
            </script>
        </div>
    </section>

    <section>
        <div data-markdown>
            <script type="text/template">
                ## Système d'exploitation

                - Le système d'exploitation est le plus important des programmes système

                - Le système d'exploitation est une interface entre les applications (logiciel) et la machine (matériel)<br>
                ➪ libérer le programmateur de la complexité du matériel
            </script>
        </div>

        <table style="text-align: center;">
            <tr style="background: #ccecff;">
                <td style="text-align: center;border:1px solid;">Applications</td>
                <td style="text-align: center;border:1px solid;">Bibliothèques</td>
                <td style="text-align: center;border:1px solid;">GUI / CLI</td>
            </tr>
            <tr style="background: #ccffcc;">
                <td colspan="3" style="text-align: center;border:1px solid;">API</td>
            </tr>
            <tr style="background: #ffff99;">
                <td colspan="3" style="text-align: center;border:1px solid;">Noyau</td>
            </tr>
            <tr style="background: #d4b2f6;">
                <td style="text-align: center;border:1px solid;">Système de fichiers</td>
                <td colspan="2" style="text-align: center;border:1px solid;">Pilotes</td>
            </tr>
            <tr style="background: #ffbbdd;">
                <td colspan="3" style="text-align: center;border:1px solid;">Matériel</td>
            </tr>
        </table>
    </section>

</section>

<section>
    <section data-markdown>
        <script type="text/template">
            # Les fichiers
        </script>
    </section>

    <section>
        <h2>Systèmes de fichiers</h2>
        <div class="flex-pad">
            <div data-markdown>
                <script type="text/template">
                    - FAT12 <small>(16 Mo/16 Mo)</small>, FAT16 <small>(2 Go/4 Go)</small>,
                     FAT32 <small>(4 Go/2 To)</small>, NTFS <small>(16 To/256 To)</small>, ExFAT <small>(128 Po/128 Po)</small>
                    - HFS <small>(2 Go/2 To)</small>, HFS+ <small>(8 Eo/8 Eo)</small>
                    - Ext2 <small>(2 To/32 To)</small>, Ext3 <small>(2 To/32 To)</small>, Ext4 <small>(16 To/1 Eo)</small>
                </script>
            </div>
            <div style="font-size:0.6em; width: 45%;" data-markdown>
                <script type="text/template">
                    | Multiples |Symbole  |Valeur         |
                    |-----------|---------|---------------|
                    |kilooctet  |ko       |10<sup>3</sup> |
                    |mégaoctet  |Mo       |10<sup>6</sup> |
                    |gigaoctet  |Go       |10<sup>9</sup> |
                    |téraoctet  |To       |10<sup>12</sup>|
                    |pétaoctet  |Po       |10<sup>15</sup>|
                    |exaoctet   |Eo       |10<sup>18</sup>|
                </script>
            </div>
        </div>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Structure d'un fichier
            - inode comportant :
              - informations relatives au fichier (type, droits d'accès...)
              - références vers les blocs de données
            - référencé par un nom (chemin d'accès)
              - sensible à la casse
              - tous les caractères sont théoriquement autorisés
              - en pratique éviter *, ? ou - en début de nom
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Structure d'un répertoire

            - considéré comme un fichier (représenté par un inode)
            - son contenu (blocs de données) est une correspondance :<br>noms de fichier ↔ inode

            ![inodes_repertoires.png](images/inodes_repertoires.png)
        </script>
    </section>

    <section>
        <h2>Organisation des fichier sous linux</h2>
        <div data-markdown style="font-size:0.6em;">
            <script type="text/template">
                Répertoire | Fonction
                ------------|--------------------------------------------------------------------------
                /bin        | Commandes essentielles pour les utilisateurs (fichiers exécutables)
                /boot       | Informations nécessaires au démarrage de la machine
                /dev        | Fichiers spéciaux correspondant aux périphériques
                /etc        | Fichiers de configuration de la machine
                /home       | Répertoires personnels des utilisateurs
                /lib        | Principales bibliothèques partagées
                /lost+found | Fragments de fichiers perdus suite à un problème de disque
                /media      | Point de montage pour les périphériques éjectables (géré par le système )
                /mnt        | Point de montage pour les périph. temporaires (géré par les utilisateurs)
                /opt        | Applications complémentaires n'appartenant pas à la distribution
                /proc       | Fichiers factices contenant des infos sur l'état du système
                /root       | Répertoire personnel de root
                /run        | Informations relatives au système depuis le dernier démarrage
                /sbin       | Commandes pour l'administrateur système (fichiers exécutables)
                /usr        | Logiciels installés avec la distribution
                /tmp        | Fichiers temporaires
                /var        | Données fréquemment écrites (logs, files d'attentes d'impressions...)
            </script>
        </div>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Droits d'accès

            ![droits_fichiers1.png](images/droits_fichiers1.png)

            ![droits_fichiers2.png](images/droits_fichiers2.png)

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Sticky bit et set UID / set GID <smaller>(1)</smaller>

            - sticky bit <small>(valeur octale : 1000)</small>
                - fichier : plus utilisé aujourd'hui
                - répertoire : un fichier du répertoire ne peut être supprimé que par son propriétaire
            - set GID <small>(valeur octale : 2000)</small>
                - fichier : le fichier est exécuté avec les droits du groupe du fichier (GID)
                - répertoire : les fichiers créés dans le répertoire héritent du groupe du répertoire (GID)
            - set UID <small>(valeur octale : 4000)</small>
                - fichier : le fichier est exécuté avec les droits du propriétaire du fichier (UID)
                - répertoire : pas de fonctionnalité définie
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Sticky bit et set UID / set GID <smaller>(2)</smaller>

            - droits d'un fichier stockés sur 12 bits : <code>sstrwxrwxrwx</code>

            - mais convention de représentation sur 9 positions
            <small>(utilisée notamment par <code>ls -l</code> ou <code>stat</code>)<small><br/>
            ![droits_spe.png](images/droits_spe.png)
        </script>
    </section>


    <section data-markdown>
        <script type="text/template">
            ## Du disque aux blocs de données

            ![disque_a_donnees.png](images/disque_a_donnees.png)

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Adressage des blocs de données

            n=15 (n=13 pour ext2/ext3)

            ![adressage_inodes.png](images/adressage_inodes.png)
        </script>
    </section>

</section>

<section>
    <section data-markdown>
        <script type="text/template">
            # Les processus <smaller>(1)</smaller>
            ## Ordonnancement
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Contexte
            - problématique : un processeur ne peut exécuter qu'une instruction à la fois<br>
            ➪ temps partagé / exécution pseudo-parallèle
            <small>(rappel de la définition : le processeur est partagé, par tranches de temps, entre plusieurs processus)</small>

            - Linux a dans son noyau un ordonnanceur qui choisit l'ordre d'exécution des processus : c'est un système d'ordonnancement préemptif
            <small>(on parle d'« interruption » : arrêt temporaire d'un processus par le processeur afin d'en exécuter un autre)</small>

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Ordonnancement
            - différentes statégies d'ordonnancement
                - système collaboratif : c'est le processus en cours d'exécution qui décide quand « passer la main »
                <small>(exemple : windows 3.1 était collaboratif, et à partir de windows 95, Microsoft a adopté un système préemptif)</small>
                - système préemptif : système qui est capable d'exécuter ou de stopper une tâche planifiée en cours
                <small>(appels systèmes, interruptions matérielles, expiration d'un quantum de temps)</small>

            - Avantage du préemptif<br>
            ➪ peut en permanence interrompre un processus, en particulier si celui-ci échoue et provoque l'instabilité du système
        </script>
    </section>

    <section>
        <h2>Découpage logique des processus</h2>
        <div class="flex-pad">
            <div style="width: 60%;" data-markdown>
                <script type="text/template">
                    - processus découpé en régions/segments<br>
                    <smaller>(segmentation, cf. « Gestion de la mémoire »)</smaller>
                </script>
            </div>
            <div style="width: 40%;" data-markdown>
                <script type="text/template">
                    - région découpée en pages<br>
                    <smaller>(pagination, cf. « Gestion de la mémoire »)</smaller>
                </script>
            </div>
        </div>
        <div data-markdown>
            <script type="text/template">
                ![orga_processus.png](images/orga_processus.png)
            </script>
        </div>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Threads (1)
            - processus constitué de threads <small>(processus léger)</small>
                - les ressources allouées à un processus <small>(temps processeur, fichiers, mémoire...)</small> sont partagées entre les threads qui le composent
                - un processus possède au moins un thread qui exécute le programme principale <small>(habituellement fonction *main()*)</small>
            - tâche = processus ou thread
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Threads (2)
            - intérêts
                - communication simple grâce aux données partagées
                - meilleure productivité d'une application avec l'exécution concurrente de threads
            - exemples
                - un navigateur est un logiciel multi-thread, le chargement d'une page laisse la main à l'utilisateur
                - une application graphique comporte de nombreux threads pour notamment traiter les évènements <small>(clavier, souris, etc.)</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Cycle de vie d'une tâche linux (états)

            <small>tâche = processus ou thread</small>

            ![etats_processus.png](images/etats_processus.png)
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Algorithmes d'ordonnancement
            - FIFO <small>(« first in - first out »)</small> : les processus accèdent au processeur chacun à leur tour, dans l'ordre d'arrivée, jusqu'à leur terminaison<br>
                - travaux courts pénalisés, pas de temps partagé
            - tourniquet <small>(« Round Robin »)</small> : les processus accèdent au processeur, chacun leur tour, pour un temps déterminé à l'avance <small>(quantum)</small><br>
                - temps partagé, équitable
            - tourniquet avec priorités dynamiques : priorité initialisée suivant la nature du processus, la priorité est baissée à chaque quantum utilisé sur le processeur<br>
                - temps partagé, prend en compte la nature et l'âge du processus
        </script>
    </section>

</section>

<section>

    <section data-markdown>
        <script type="text/template">
            # Les processus <smaller>(2)</smaller>
            ## Synchronisation
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Synchronisation des processus

            - avec le temps partagé, des tâches peuvent accéder de manière concurrente à des données partagées. On ne peut prévoir l'ordre d'exécution des instructions (préemption, interruptions systèmes...), alors comment garantir la cohérence des données ?<br>
            ➪ synchroniser les processus afin d'éviter des conflits d'accès<br>

            - de manière générale, on parle de ressources partagées. Par exemple, l'imprimante :
                - plusieurs tâches ne peuvent pas imprimer en même temps
                - il faut synchroniser les tâches afin qu'elles accèdent chacune à leur tour à l'imprimante : «&nbsp;spool&nbsp; » d'impression
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Section critique / Exclusion mutuelle
            Mise en place de primitives de synchronisation<br>
            afin d'obtenir un accès exclusif aux données

            - section critique :
                - portion de code qui doit être exécuté par seulement une tâche à la fois
                - ou plus généralement, ressource partagée dont l'utilisation n'est faite que par un processus à la fois

            - exclusion mutuelle : primitive de synchronisation qui permet d'éviter que des ressources partagées ne soient utilisées en même temps
        </script>
    </section>

    <section>
        <div data-markdown>
            <script type="text/template">
                ## Exclusion mutuelle avec attente active <small>(1)</small>
                <small>verrou : variable commune, initialisée à faux</small>
            </script>
        </div>
        <div class="flex-pad">
            <div style="width: 50%;">
                <b>P1</b>
                <pre><code data-noescape style="margin-left:-100px;">
                    ...
                    <span class="fragment" data-fragment-index="1"><b>Tant que</b> (verrou) <b>Faire</b>
                        sleep(délai);
                    <b>Fin tant que;</b></span>
                    <span class="fragment" data-fragment-index="4">verrou = vrai;
                    <b>&lt;section critique&gt;</b></span>
                    <span class="fragment" data-fragment-index="5">verrou = faux;</span>
                    ...
                </pre></code>
            </div>
            <div style="width: 50%;">
                <b>P2</b>
                <pre><code data-noescape style="margin-left:-100px;">
                    ...
                    <span class="fragment" data-fragment-index="2"><b>Tant que</b> (verrou) <b>Faire</b>
                        sleep(délai);
                    <b>Fin tant que;</b></span>
                    <span class="fragment" data-fragment-index="3">verrou = vrai;
                    <b>&lt;section critique&gt;</b></span>
                    <span class="fragment" data-fragment-index="6">verrou = faux;</span>
                    ...
                </pre></code>
            </div>
        </div>
        <span class="fragment" data-fragment-index="4">➪ incorrect !! P1 et P2 peuvent arriver dans leur section critique en même temps</span>
    </section>

    <section>
        <h2>Exclusion mutuelle avec attente active <small>(2)</small></h2>
        Solution de l'alternance<br>
        <small>tour : variable commune, initialisée à 1 (quand tour = i, P<sub>i</sub> peut entrer en section critique)</small>

        <div class="flex-pad">
            <div style="width: 50%;">
                <b>P1</b>
                <pre><code data-noescape style="margin-left:-140px;">
                    <b>Répéter</b>
                        <b>Tant que</b> (tour = 2) <b>Faire</b>
                            sleep(délai);
                        <b>Fin tant que;</b>
                        <b>&lt;section critique&gt;</b>
                        tour = 2;
                    <b>Jusqu'à</b> faux
                </pre></code>
            </div>
            <div style="width: 50%;">
                <b>P2</b>
                <pre><code data-noescape style="margin-left:-140px;">
                    <b>Répéter</b>
                        <b>Tant que</b> (tour = 1) <b>Faire</b>
                            sleep(délai);
                        <b>Fin tant que;</b>
                        <b>&lt;section critique&gt;</b>
                        tour = 1;
                    <b>Jusqu'à</b> faux
                </pre></code>
            </div>
        </div>
        <div data-markdown>
            <script type="text/template">
                - inconvénient : pour rentrer à nouveau en section critique, P<sub>i</sub> doit attendre que P<sub>j</sub>
                exécute sa section critique (stricte alternance des 2)
                - autre inconvénient lié à l'attente active : impose des tests constants ➪ grosse consommation de l'UC
            </script>
        </div>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Sémaphore <small>(1)</small>

            - outil permettant la bonne gestion des sections critiques sans l'inconvénient de l'attente active <smaller>(lorsqu'une section critique est disponible, réveil des autres processus qui la demandent)</smaller>

            - implémenté par une structure « s » accessible par une variable partagée
                - <code>**val**</code> : entier
                - <code>**file**</code> : file de processus en attente
                <small>➪ à l'initialisation, val indique le nombre de processus pouvant accéder simultanément à la section critique.<br>Si val = 1, on est dans le cas de l'exclusion mutuelle.</small>

            - fonctionne avec deux opérations traitées comme des appels atomiques (solution matérielle)
                - <code>**P(s)**</code> : « prendre » le sémaphore, on demande l'accès à la section critique
                - <code>**V(s)**</code> : « relacher » le sémaphore, on libère l'accès à la section critique
        </script>
    </section>

    <section>
        <h2>Sémaphore <small>(2)</small></h2>

        <p>Soit <i>p</i> le processus qui effectue P(s) et V(s)</p>
        <div class="flex-pad">
            <div style="width: 50%;">
                <code><b>P(s)</b></code>
                <pre><code data-noescape style="margin-left:-140px;">
                    s.val = s.val - 1;
                    <b>Si</b> (s.val < 0) <b>Alors</b>
                        ajouter(s.file, <i>p</i>);
                        p.état = stoppé;
                    <b>Fin Si;</b>
                </pre></code>
            </div>
            <div style="width: 50%;">
                <code><b>V(s)</b></code>
                <pre><code data-noescape style="margin-left:-140px;">
                    s.val = s.val + 1;
                    <b>Si</b> (s.val >= 0) <b>Alors</b>
                        eligible = retirer(s.file);
                        eligible.état = prêt;
                    <b>Fin Si;</b>
                </pre></code>
            </div>
        </div>
        <div data-markdown>
            <script type="text/template">
                Utilisation pour l'exclusion mutuelle <small>(s.val = 1)</small>
                <pre style="width:50%;"><code data-noescape>
                    ...
                    P(s);
                    <b>&lt;section critique&gt;</b>
                    V(s);
                    ...<br>
                </pre></code>
            </script>
        </div>
    </section>

    <section>
        <div data-markdown>
            <script type="text/template">
                ## Sémaphore <small>(3)</small>

                Problèmes d'algorithmes de synchronisation

                - famine : un processus peut se voir refuser l'accès à une section critique pendant un temps indéterminé, il est dit alors que le processus est en famine.<br><br>
                    - exemple dû à un oubli de libération de la section critique
            </script>
        </div>
        <div class="flex-pad">
            <div style="width: 50%;">
                <b>P1</b>
                <pre><code data-noescape style="margin-left:-140px;">
                    <span class="fragment" data-fragment-index="2">
                    ...
                    P(s);</span>
                    <span class="fragment" data-fragment-index="3"><b>&lt;section critique&gt;</b>
                    ...<br>
                    </span>
                </pre></code>
            </div>
            <div style="width: 50%;">
                <b>P2</b>
                <pre><code data-noescape style="margin-left:-140px;">
                    <span class="fragment" data-fragment-index="4">
                    ...
                    P(s);
                    <span class="fragment" data-fragment-index="6"><b>&lt;section critique&gt;</b>
                    V(s);
                    ...
                    </span>
                </pre></code>
            </div>
        </div>
        <div style="position:relative">
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="1"><small>s.val = 1</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="2"><small>s.val = 0</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="3"><small>s.val = 0</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="4"><small>s.val = -1, <span style="color:red">P2.état = stoppé</span></small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="5"><small style="color:red">FAMINE !!</small></p>
        </div>
    </section>

    <section>
        <div data-markdown>
            <script type="text/template">
                ## Sémaphore <small>(4)</small>

                Problèmes d'algorithmes de synchronisation

                - interblocage : plusieurs processus s'attendent mutuellement. Aucun des processus ne peut s'exécuter, libérer sa section critique ou être réveillé.<br>

                    - exemple
            </script>
        </div>
        <div class="flex-pad">
            <div style="width: 50%;">
                <b>P1</b>
                <pre><code data-noescape style="margin-left:-140px;">
                    <span class="fragment" data-fragment-index="2">...
                    P(s<sub><small>1</small></sub>);</span>
                    <span class="fragment" data-fragment-index="4">P(s<sub><small>2</small></sub>);</span>
                    <span class="fragment" data-fragment-index="7"><b>&lt;section critique&gt;</b>
                    V(s<sub><small>1</small></sub>)
                    V(s<sub><small>2</small></sub>)
                    ...</span></pre></code>
            </div>
            <div style="width: 50%;">
                <b>P2</b>
                <pre><code data-noescape style="margin-left:-140px;">
                    <span class="fragment" data-fragment-index="3">...
                    P(s<sub><small>2</small></sub>);</span>
                    <span class="fragment" data-fragment-index="5">P(s<sub><small>1</small></sub>);</span>
                    <span class="fragment" data-fragment-index="7"><b>&lt;section critique&gt;</b>
                    V(s<sub><small>2</small></sub>)
                    V(s<sub><small>1</small></sub>)
                    ...</span></pre></code>
            </div>
        </div>
        <div style="position:relative">
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="1"><small>s<sub><smaller>1</smaller></sub>.val = 1, s<sub><small>2</small></sub>.val = 1</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="2"><small>s<sub><smaller>1</smaller></sub>.val = 0, s<sub><small>2</small></sub>.val = 1</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="3"><small>s<sub><smaller>1</smaller></sub>.val = 0, s<sub><small>2</small></sub>.val = 0</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="4"><small>s<sub><smaller>1</smaller></sub>.val = 0, s<sub><small>2</small></sub>.val = -1</small>, <small style="color:red">P1.état = stoppé</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="5"><small>s<sub><smaller>1</smaller></sub>.val = -1, s<sub><small>2</small></sub>.val = -1</small>, <small style="color:red">P1.état = stoppé, P2.état = stoppé</small></p>
            <p class="fragment current-visible" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="6"><small style="color:red">INTERBLOCAGE !!</small></p>
        </div>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Sémaphore <small>(5)</small>

            Modélisation avec graphes orientés

            ![graphes_semaphores.png](images/graphes_semaphores.png)

            a) le processus A détient la ressource R<br>
            b) le processus B est en attente de la ressource S<br>
            c) les processus C et D sont en interblocage

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Sémaphore <small>(6)</small>
            - inconvénients des sémaphores
                - erreurs de synchronisation difficiles à détecter
                - erreurs fréquentes dûes aux développeurs provoquant notamment des interblocages ou des famines<br>
                <small>(oubli de faire un V(s) après accès à sa zone critique, inverser un P(s) et un V(s), etc.)</small>
            - tendance des langages de programmation de haut niveau à intégrer des primitives plus évoluées de synchronisation<br>
            ➪ moniteur
        </script>
    </section>

    <section>
        <div data-markdown>
            <script type="text/template">
                ## Moniteur

                - la structure du moniteur ne permet qu'à un seul processus à la fois d'être actif à l'intérieur d'un moniteur. Par conséquent, le programmeur n'a pas besoin de coder explicitement la synchronisation, c'est le compilateur qui s'en charge.

                - exemple de moniteur avec les verrous « synchronized » en Java
            </script>
        </div>
        <div class="flex-pad">
            <div style="width: 50%;">
                <small>sur une méthode</small>
                <pre><code data-noescape style="margin-left:-140px;">
                    <b>synchronized void</b> methode() {
                        <span style="color:grey">// section critique</span>
                    }
                </pre></code>
            </div>
            <div style="width: 50%;">
                <small>sur une variable</small>
                <pre><code data-noescape style="margin-left:-140px;">
                    <b>void</b> methode() {
                        <b>synchronized</b>(this) {
                            <span style="color:grey">// section critique</span>
                        }
                    }
                </pre></code>
            </div>
        </div>
    </section>
</section>

<section>
    <section data-markdown>
        <script type="text/template">
            # Gestion de la mémoire
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
			## Mémoire virtuelle
			- La taille d'un programme, des données et de la pile peut dépasser la mémoire disponible. Le système garde en mémoire les parties du programme qui sont utilisées et stocke le reste sur le disque.
			- extension de la mémoire vive : mémoire virtuelle > mémoire réelle
			- système de va-et-vient / « swapping » : mouvement des processus entre la mémoire principale (vive) et la mémoire secondaire (disque dur, flash, etc.)
			- par ex. sous linux : partition swap
			![memoire_virtuelle_linux.png](images/memoire_virtuelle_linux.png)
        </script>
    </section>

    <section>
		<div data-markdown>
			<script type="text/template">
				## Mémoire virtuelle <small>(2)</small>

				- par ex. sous windows : fichier réservé
				- paramétrage avec windows 10 : <small>« Panneau de configuration » / « Régler l'apparence et les performances de Windows »</small>
			</script>
		</div>
		<div class="flex-pad">
	        <div style="width: 50%;">
	            <img src="images/memoire_virtuelle_win10_1.png" alt="memoire_virtuelle_win10_1.png" style="height: 430px;">
	        </div>
	        <div style="width: 50%;">
	            <img src="images/memoire_virtuelle_win10_2.png" alt="memoire_virtuelle_win10_2.png" style="height: 430px;">
	        </div>
	   </div>
    </section>

    <section data-markdown>
        <script type="text/template">
			## Mécanismes d'organisation de la mémoire <small>(1)</small>

			- la pagination
				- découpage des espaces d'adressage de la mémoire vive en zones égales (pages) afin de les sauvegarder dans la mémoire virtuelle et de les restaurer en mémoire vive suivant les besoins
				- *but* : obtenir un grand espace d'adressage linéaire sans avoir à acheter de la mémoire
 physique
				- *inconvénient* : fragmentation interne <small>(la taille allouée étant un multiple de la taille d'une page, il y a un gaspillage lié à l'ensemble des pages qui ne sont pas complètement occupées)</small>
        </script>
    </section>

	<section data-markdown>
        <script type="text/template">
			## Mécanismes d'organisation de la mémoire <small>(2)</small>
			- la segmentation
				- séparation des programmes et des données dans des espaces d'adressage logiquement indépendants
				- *but* :  faciliter le partage et la protection
				- *inconvénient* : fragmentation externe <small>(gaspillage de zones mémoires contiguës qui deviennent trop petites pour être occupées par la plupart des données)
        </script>
    </section>


    <section data-markdown>
        <script type="text/template">
            ## Fragmentation externe <small>(exemple)</small>

            ![fragmentation_externe.png](images/fragmentation_externe.png)
- 660 ko de mémoire libre mais un processus de 600 ko ne peut être chargé car la mémoire n'est pas contiguë
- possibilité de défragmentation mais solution coûteuse
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
            ## Pagination, remplacement de page
            - lorsqu'un processus veut accéder à une page qui se trouve en zone en swap<br>
            ➪ défaut de page, *« demand paging »* : chargement de la page dans un cadre de page en mémoire vive

            - si tous les cadres sont occupés : il faut un choisir un, sauvegarder son contenu en zone de swap (*« swap out »*) et charger la page dans celui-ci
            - quelle page choisir ?<br>
            ➪ algorithmes de remplacement de page
            <small>l'algorithme optimal est celui qui consiste à retirer la page qui sera par la suite la moins utilisée (irréalisable dans la pratique)</small>
        </script>
    </section>
</section>

<!-- Notes supplémentaires
- synchrone : le processus appelant attend que le processus a envoyé sa réponse pour continuer
- asynchrone : le processus appelant continue à travailler puis gère via un évènement le retour du processus appelé -->
</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
// More info https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    // Display the page number of the current slide
    slideNumber: true,
    // Transition style
    transition: 'concave', // none/fade/slide/convex/concave/zoom

    // More info https://github.com/hakimel/reveal.js#dependencies
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        // Interpret Markdown in <section> elements
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        // Syntax highlight for <code> elements
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        // Zoom in and out with Alt+click
        { src: 'plugin/zoom-js/zoom.js', async: true },
        // Speaker notes
        { src: 'plugin/notes/notes.js', async: true }
    ]
});
</script>
</body>
</html>
